# 算法总结

[TOC]



## 1.数组

### 数组理论基础

数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力

也就是说，想法很简单，但实现起来 可能就不是那么回事了。

首先要知道数组在内存中的存储方式，这样才能真正理解数组相关的面试题

**数组是存放在连续内存空间上的相同类型数据的集合。**

数组可以方便的通过下标索引的方式获取到下标下对应的数据。

举一个字符数组的例子，如图所示：

![算法通关数组](https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%84.png)

需要两点注意的是

**数组下标都是从0开始的。**

**数组内存空间的地址是连续的**

正是因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。

例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示：

![算法通关数组1](https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%841.png)

而且大家如果使用C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。

**数组的元素是不能删的，只能覆盖。**

那么二维数组直接上图，大家应该就知道怎么回事了

![算法通关数组2](https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%842.png)

**那么二维数组在内存的空间地址是连续的么？**

不同编程语言的内存管理是不一样的，在C++中二维数组是连续分布的。



![数组内存](https://code-thinking-1253855093.file.myqcloud.com/pics/20210310150641186.png)

**所以可以看出在C++中二维数组在地址空间上是连续的**。

像Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。

所以看不到每个元素的地址情况，这里我以Java为例，也做一个实验。

```java
public static void test_arr() {
    int[][] arr = {{1, 2, 3}, {3, 4, 5}, {6, 7, 8}, {9,9,9}};
    System.out.println(arr[0]);
    System.out.println(arr[1]);
    System.out.println(arr[2]);
    System.out.println(arr[3]);
}
```

输出的地址为：

```text
[I@7852e922
[I@4e25154f
[I@70dea4e
[I@5c647e05
```

这里的数值也是16进制，这不是真正的地址，而是经过处理过后的数值了，我们也可以看出，二维数组的每一行头结点的地址是没有规则的，更谈不上连续。

所以Java的二维数组可能是如下排列的方式：

![算法通关数组3](https://code-thinking-1253855093.file.myqcloud.com/pics/20201214111631844.png)

### 代码随想录题目

1.1二分查找:https://www.programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html

1.2移除元素:https://www.programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html

1.3有序数组的平方:https://www.programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html

1.4长度最小的字数组:https://www.programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html

1.5螺旋矩阵:https://www.programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html

### 自己遇到的题目

### 1.1 找规律

```txt
题目中会给你一个整数数组 `num`，`num=[1,2,2,3,3,3.....]`，然后题目中会给你一个整数 `k`，现在请你找出 `num` 的规律，并编写代码计算数组的前 `k` 项和为多少？


输入格式 一个整数`k`。

输出格式 一个整数。

输入输出样例1输入`5`输出 `11`

输入输出样例2输入 `10`输出 `30`
```



```java
package org.example;
import java.util.*;
import java.util.Scanner;
public class BankRate {
  
        public static void main(String[] args) {
            Scanner sc =new Scanner(System.in);

            int k = sc.nextInt();

            int sum = 0; // 存储前k项的和
            int currentNum = 1; // 当前要添加的数字
            int count = 0; // 已添加的项数

            // 计算前k项和
            while (count < k) {
                for (int i = 0; i < currentNum; i++) {
                    sum += currentNum; // 累加当前数字
                    count++; // 增加已处理的项数
                    // 检查是否已经达到k项
                    if (count == k) {
                        break;
                    }
                }
                currentNum++; // 移动到下一个数字
            }

            // 输出前k项和
            System.out.println(sum);
        }



}
```

### 1.2 数组的排列方式

```txt
小叶同学最近正在学习数组。在做题的时候，他发现了一道关于数组的题，却没有办法做出来，想让你帮他一下。

题目中首先会给你一个整数 `n`，代表 `1` 到 `n` 之间的数字，你可以无限使用 `1` 到 `n` 之间的数字。然后题目中会给你一个整数 `k`，需要你从这 `n` 个数字中取出 `k` 个数字，并按顺序排列起来，但是相邻的数字不能相同，小叶同学想知道这样有多少种排列方法，现在请你帮小叶编写代码，算出结果并输出。（结果对 `1000000007` 取模）

输入格式一行两个整数，`n` 和 `k`。

输出格式 一个整数。

输入输出样例1输入 2 2输出2

输入输出样例2输入1 5输出 `5`
```



```java
import java.util.Scanner;

public class Main {

    private static final long MOD = 1000000007; // 定义常量MOD为固定值1000000007

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in); // 使用Scanner类从键盘获取输入
        int n = sc.nextInt(); // 读取整数n
        int m = sc.nextInt(); // 读取整数m

        long[] dp = new long[m + 1];
        dp[1] = m;

        for (int i = 2; i <= m; i++) {
            dp[i] = dp[i-1] * (m - 1) % MOD; // 更新dp[i]
        }

        System.out.println(dp[m]); // 输出结果
    }
}

```

### 1.3 数组求最值

```txt
岳岳经过不断的努力终于加上n 个学弟学妹的微信，以至于现在每天每个学弟学妹都会问a 个问题现在岳岳想找到一个星期内问问题最频繁的学妹(就是排除学弟) 然后请她吃饭作为奖励，请你设计一个程序计算出来

输入
第一行 一个整数 n 表示学弟学妹的总个数
第二行 n 个整数，分别表示第i 名学生的性别。 0 表示为学妹，1 表示为学弟(1≤i ≤n )
接下来七行 每行有n 个整数ai ，每个数字表示第i 名学生当天问的问题数量

输出
一个整数 ans   表示问题最频繁的学妹的编号
测试点数据规模与约定
对于100%的测试点，保证有唯一答案
对于100%的测试点，保证1<n <5，0<ai <10

样例输入
3
0 0 1
2 3 9
1 3 9
4 3 9
2 3 9
1 3 9
2 3 9
0 2 1
样例输出
2
提示
样例中第三个同学问问题是最频繁的但是他不是学妹，所以输出2表示第二个学妹
```

```java
//一维数组解法
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int max = 0;
        int ans = 0;
        //判断是否需要比较
        boolean[] peop = new boolean[n];
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            peop[i] = sc.nextInt()==0;//如果输入等于0，将true值赋给peop
//如果输入不等于0，则表达式的结果为false，将该值赋给peop
        }
        //统计每人问题的次数
        for (int i = 0; i < 7; i++) {
            for (int j = 0; j < n; j++) {
                arr[j] += sc.nextInt();
            }
        }
        //找到最大值，输出
        for (int i = 0; i < n; i++) {
            if(peop[i]){
                if(arr[i]>max){
                     max = arr[i];
                     ans = i;
                }``12234            }
        }
        System.out.println(ans+1);
    }
}
```

```java
//二维数组解法
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int max = 0;
        int ans = 0;

        // 判断学生性别
        boolean[] isSister = new boolean[n];
        for (int i = 0; i < n; i++) {
            isSister[i] = sc.nextInt() == 0;
        }

        // 统计每人问题的次数
        int[][] questions = new int[7][n];
        for (int i = 0; i < 7; i++) {
            for (int j = 0; j < n; j++) {
                questions[i][j] = sc.nextInt();
            }
        }

        // 找到问题提问最频繁的学妹
        for (int i = 0; i < n; i++) {
            if (isSister[i]) {
                int totalQuestions = 0;
                for (int j = 0; j < 7; j++) {
                    totalQuestions += questions[j][i];
                }
                if (totalQuestions > max) {
                    max = totalQuestions;
                    ans = i + 1; // 学妹的编号是从1开始的
                }
            }
        }

        System.out.println(ans);
    }
}
```



## 2.链表

### 链表理论基础

什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。

链表的入口节点称为链表的头结点也就是head。

如图所示： ![链表1](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194529815.png)

链表的类型 接下来说一下链表的几种类型:

**单链表**

刚刚说的就是单链表。

**双链表**

单链表中的指针域只能指向节点的下一个节点。

双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。

双链表 既可以向前查询也可以向后查询。

如图所示： ![链表2](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194559317.png)

**循环链表**

循环链表，顾名思义，就是链表首尾相连。

循环链表可以用来解决约瑟夫环问题。

![链表4](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194629603.png)

**链表的存储方式**

了解完链表的类型，再来说一说链表在内存中的存储方式。

数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。

链表是通过指针域的指针链接在内存中各个节点。

所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

如图所示：

![链表3](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194613920.png)

这个链表起始节点为2， 终止节点为7， 各个节点分布在内存的不同地址空间上，通过指针串联在一起。

**链表的操作**

**删除节点**

删除D节点，如图所示：

![链表-删除节点](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195114541-20230310121459257.png)

只要将C节点的next指针 指向E节点就可以了。

那有同学说了，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。

是这样的，所以在C++里最好是再手动释放这个D节点，释放这块内存。

其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。

**添加节点**

如图所示：

![链表-添加节点](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195134331-20230310121503147.png)

可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。

但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。

性能分析

再把链表的特性和数组的特性进行一个对比，如图所示：

![链表-链表与数据性能对比](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195200276.png)

数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。

链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。

### 代码随想录题目

2.1移除链表元素:https://www.programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html

2.2设计链表:https://www.programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html

2.3翻转链表:https://www.programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html

2.4两两交换链表中的节点:https://www.programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html

2.5删除链表的倒数第N个节点:https://www.programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html

2.6链表相交:https://www.programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html

2.7环形链表https://www.programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html

### 自己遇到的题目



## 3.哈希表

### 哈希表理论基础

**哈希表**

首先什么是 哈希表，哈希表（英文名字为Hash table，国内也有一些算法书籍翻译为散列表，大家看到这两个名称知道都是指hash table就可以了）。

> 哈希表是根据关键码的值而直接进行访问的数据结构。

这么这官方的解释可能有点懵，其实直白来讲其实数组就是一张哈希表。

哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示：

![哈希表1](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104234805168.png)

那么哈希表能解决什么问题呢，**一般哈希表都是用来快速判断一个元素是否出现集合里。**

例如要查询一个名字是否在这所学校里。

要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。

我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。

将学生姓名映射到哈希表上就涉及到了**hash function ，也就是哈希函数**。

**哈希函数**

哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。

哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。

![哈希表2](https://code-thinking-1253855093.file.myqcloud.com/pics/2021010423484818.png)

如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？

此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。

此时问题又来了，哈希表我们刚刚说过，就是一个数组。

如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。

接下来**哈希碰撞**登场

**哈希碰撞**

如图所示，小李和小王都映射到了索引下标 1 的位置，**这一现象叫做哈希碰撞**。

![哈希表3](https://code-thinking-1253855093.file.myqcloud.com/pics/2021010423494884.png)

一般哈希碰撞有两种解决方法， 拉链法和线性探测法。

**拉链法**

刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了

![哈希表4](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235015226.png)

（数据规模是dataSize， 哈希表的大小为tableSize）

其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。

**线性探测法**

使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。

例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：

![哈希表5](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235109950.png)

其实关于哈希碰撞还有非常多的细节，感兴趣的同学可以再好好研究一下，这里我就不再赘述了。

**常见的三种哈希结构**

当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。

- 数组
- set （集合）
- map(映射)

这里数组就没啥可说的了，我们来看一下set。

在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。

当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。

那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。

其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。

虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。

这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？

实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。

![哈希表6](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235134572.png)

**总结**

总结一下，**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。

但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

### 代码随想录题目

3.1有效的字母异位词:https://www.programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html

3.2两个数组的交集:https://www.programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE

3.3快乐数:https://www.programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html#%E6%80%9D%E8%B7%AF

3.4两数之和:https://www.programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html

3.5四数相加II:https://www.programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html

3.6赎金信:https://www.programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html#%E6%80%9D%E8%B7%AF

3.7三数之和:https://www.programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html

3.8四数之和:https://www.programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html

### 自己遇到的题目

### 3.1卡牌游戏 

```txt
题目描述
阿岳在玩卡片拼接游戏，游戏规则如下:
每次会给你n张卡片，每张卡片上都会有一个字符，你需要将所有不重复的卡片按照ASCLL进行从大到小的排序，
得到的是无重复有序的字符串
输入
一个字符串s  表示所有的卡片

输出
一个有序且不重复的字符串

测试点数据规模与约定
对于100%的测试点，保证s 中所有的字符都是小写字母，且0≤s.length() ≤105

样例输入
aabcc
样例输出
cba
```

```java
//方法一 哈希表
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        char[] c = sc.nextLine().toCharArray();
        //arr数组记录每个字母是否出现
        boolean[] arr = new boolean[26];
        for(char temp : c){
            arr[temp - 'a'] = true;// arr[temp - 97] = true;
        }
        //从后往前输出字符串出现的字母
        for (int i = 25; i >= 0; i--) {
            if(arr[i]){
                System.out.print((char)(97+i));
            }
        }
    }
}
```



## 4.字符串

### 字符串理论基础

### 代码随想录题目

4.1反转字符串:https://www.programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE

4.2反转字符串II:https://www.programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html

4.3 替换数字:https://www.programmercarl.com/kama54.%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97.html

4.4翻转字符串里的单词:https://www.programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html

4.5右旋字符串:https://www.programmercarl.com/kama55.%E5%8F%B3%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2.html

4.6实现 strStr():https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html

4.7重复的子字符串:https://www.programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html

### 自己遇到的题目

### 4.1 判断密码

```txt
在一个新的软件上注册账号时，填写密码时，网站通常都有一个标准，以防止你的密码设置的太简单。现在想请你编写代码，完成这个功能。

题目中会给你一个字符串 `s` 代表新建立的密码，密码需要符合两个条件才算合格：首先，密码长度要大于等于六；其次，密码中需要包含大写字母，小写字母和数字。

现在请你编写代码，判断用户注册的新密码是否合格，如果合格，则返回 `True`，否则返回 `False`。

输入格式** 一个字符串 `s`。

*输出格式** `True` 或 `False`。

输入输出样例1**输入** `abc`**输出** `False`

输入输出样例2 输入** `abcA12`**输出** `True`
```



```java
package org.example;

import java.util.Scanner;
public class BankRate {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.next();
        int if_len = 0;
        int if_num = 0;
        int if_ABC = 0;
        int if_abc = 0;
        char[] charArray;
        charArray = str.toCharArray();
        if(str.length()>=6){
            if_len++;
        }
        for (int i = 0; i < charArray.length; i++) {
            if(charArray[i]<='9'&&charArray[i]>='0'){
                if_num++;
            }
            if(charArray[i]<='z'&&charArray[i]>='a'){
                if_abc++;
            }
            if (charArray[i]<='Z'&&charArray[i]>='A'){
                if_ABC++;
            }
        }
        if(if_len==1&&if_num>0&&if_abc>0&&if_ABC>0){
            System.out.println("True");
        }else{
            System.out.println("False");
        }

    }
}
```

### 4.2找字符串

```txt
经过前两次的失败，小明终于在他喜欢的女孩子面前不结巴。所以他鼓起勇气尝试了第三次表白，题目中会给你一个字符串 `s`，请你找到 `s` 中小明说了多少次 `love`？如果没有找到，请输出表白失败，现在请你编写代码计算并输出结果。

输入格式 一个字符串 `s`。

输出格式 一个整数。

输入输出样例1输入 `lov`输出 `表白失败`

输入输出样例2输入 `lllovell`输出** `1`
```



```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        int count = 0;
        int index = 0;

        while ((index = s.indexOf("love", index)) != -1) {
            count++;
            index += 4;  // 跳过找到的 "love"
        }

        if (count == 0) {
            System.out.println("表白失败");
        } else {
            System.out.println(count);
        }
    }
}

```

### 4.3最长子串

```txt
题目中会给你两个字符串 `s1` 和 `s2`。定义他们子串的方式是在某一个字符串 `s` 中删除一些元素（可以删除零个元素），剩下的元素就是 `s` 的子串。如 `s="abcd"`，删除 `c` 后，`abd` 就是他的子串之一。

其次，`s1` 的子串不能是 `s2` 的子串。`s2` 的子串不能是 `s1` 的子串。现在请你编写代码计算 `s1` 和 `s2` 所有子串中，最长的子串的长度。

 第一行，一个字符串 `s1`。 第二行，一个字符串 `s2`。

输出格式一个整数。

输入输出样例1输入 abc|abc输出-1

输入输出样例2输入 zbc|abc输出 3
```



```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner in =new Scanner(System.in);
        String str1=in.next();
        String str2=in.next();
        if (str1.equals(str2)){
            System.out.println(-1);
            return;
        }
        int max=Math.max(str1.length(),str2.length());
        System.out.println(max);
    }
}
```

### 4.4回文时钟

```txt
小爱同学最近特别迷恋回文字符串。以至于他看时间都想找到回文字符串，现在题目中会给你一个时间字符串 `s`（形式如 `HH:MM` 24 小时制）请你找到这一个时刻之前的一个回文时间和之后的一个回文时间并输出。

如 `s=01:00`，之前的一个回文时间为 `00:00`,之后的一个回文时间为 `01:10`。但输出输出不含前导 `0`。故输出 `0:0,1:10`。

现在请你编写代码，完成上述操作。

输入格式 一个字符串 `s`。

输出格式 第一行，一个字符串代表之前的一个回文时间。 第二行，一个字符串代表之后的一个回文时间。

输入输出样例

输入 `01:00`

输出 `0:0` `1:10`

输入输出样例2

输入 `05:25`

输出 `4:40` `5:50`
```



```java
import java.util.Scanner;

public class Main {

    public static int abc(int a, int b) {  // Function to check if the time is palindromic
        int t = 0;
        if (a / 10 == b % 10 && a % 10 == b / 10)
            t = 1;
        return t;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String input = sc.nextLine();
        int x, y, m, n;
        x = Integer.parseInt(input.substring(0, 2));
        y = Integer.parseInt(input.substring(3, 5));
        int z = x * 60 + y;

        // Search for the nearest palindromic time before the given time
        for (int i = z - 1; i >= 0; i--) {
            m = i / 60;
            n = i % 60;
            if (abc(m, n) == 1) {
                System.out.println(m + ":" + n);
                break;
            }
        }

        // Search for the nearest palindromic time after the given time
        for (int i = z + 1; i < 1440; i++) {
            m = i / 60;
            n = i % 60;
            if (abc(m, n) == 1) {
                System.out.println(m + ":" + n);
                break;
            }
        }
    }
}

```

### 4.5 字符串时间处理

```txt
小艾现在想统计他每次做作业会花多长时间，所以他记录了开始写作业和写完作业的时间，想让你帮他计算一下花了多少秒。

题目中会给你两个时间，时间格式为 `xdayHH:MM:SS`，现在请你编写代码，帮小艾计算他写作业花了多少秒？

输入格式两行，每行一个时间。

输出格式 一个整数。

输入输出样例1输入1day03:00:12   1day04:00:12 输出 3600

输入输出样例2输入123day15:00:01  19999day15:00:00 输出 1717286399
```



```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // Read the two times as strings
        String startTime = scanner.nextLine();
        String endTime = scanner.nextLine();
        
        // Parse the strings and calculate the duration in seconds
        long durationInSeconds = calculateDurationInSeconds(startTime, endTime);
        
        // Output the duration in seconds
        System.out.println(durationInSeconds);
        
        scanner.close();
    }

    private static long calculateDurationInSeconds(String start, String end) {
        // Extract the day, hours, minutes, and seconds from the start time
        int startDay = Integer.parseInt(start.substring(0, start.indexOf("day")));
        int startHour = Integer.parseInt(start.substring(start.indexOf("day") + 3, start.indexOf(":")));
        int startMinute = Integer.parseInt(start.substring(start.indexOf(":") + 1, start.lastIndexOf(":")));
        int startSecond = Integer.parseInt(start.substring(start.lastIndexOf(":") + 1));
        
        // Extract the day, hours, minutes, and seconds from the end time
        int endDay = Integer.parseInt(end.substring(0, end.indexOf("day")));
        int endHour = Integer.parseInt(end.substring(end.indexOf("day") + 3, end.indexOf(":")));
        int endMinute = Integer.parseInt(end.substring(end.indexOf(":") + 1, end.lastIndexOf(":")));
        int endSecond = Integer.parseInt(end.substring(end.lastIndexOf(":") + 1));
        
        // Convert everything to seconds
        long startInSeconds = (long)startDay * 86400 + startHour * 3600 + startMinute * 60 + startSecond;
        long endInSeconds = (long)endDay * 86400 + endHour * 3600 + endMinute * 60 + endSecond;
        
        // Calculate the duration in seconds
        return endInSeconds - startInSeconds;
    }
}

```

### 4.6 只有ab组成的字符串

```txt
现在题目中会给你一个字符串 `s`，请你判断该字符串是否由若干个 `ab` 组成的。其中，如果 `ab` 顺序不对或者没有组成完整的 `ab` 或者出现了其他元素，`s` 都不算由 `ab` 组成。在请你编写代码并判断 `s` 是否只由 `ab` 组成。如果是，则返回 `True`，否则返回 `False`。

输入格式 一个字符串 `s`。

输出格式 `True` 或 `False`。

输入输出样例1输入 `ab`输出 `True`

输入输出样例2输入 `aba`输 `False`
```



```java
private static boolean is MadeOfAB(String s){
	if(s.length()%2!=0){
        return false;
    }
    for(int i =0;i<length();i+=2){
        if(s.chatAt(i)!=a||s.chatAt(i+1)!='b'){
            return false;
        }
    }
    return true;
}
```

### 4.7比较字符串

```txt
有一天，阿岳的信息安全老师布置了一个作业，要求编写一个程序，比较两个相同进制（2进制~16进制）的数值大小。从键盘上输入两个正确（数码符合当前进制）的相同进制的数值字符串（不带正负号，没有小数点），比较大小，输出“>”，“<”或者"="。注意：设计的算法与具体的进制无关。阿岳一看到这个题目，就觉得很有趣，直接上手做起来。

**输入**

第一行 一个字符串*Sa* 表示参与比较的第一个字符串
第一行 一个字符串*Sb* 表示参与比较的第二个字符串

**输出**

一个字符 表示比较的结果("<"、">"或"=")

**测试点数据规模与约定**

对于100%的测试点，保证0<*Sa.length* ,*Sb.length* <100
样例输入
123
1234
样例输出
<
```

```java
使用ASCII比较即可
import java.util.*;
public class q1538 {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		cmp(sc.next(),sc.next());
	}
	
	public static void cmp(String s1,String s2) {
		boolean flag=false;
		if(s1.length()>s2.length()) System.out.println(">");
		else if(s1.length()<s2.length()) System.out.println("<");
		else {
			for(int i=0;i<s1.length();i++) {
				if(s1.charAt(i)>s2.charAt(i)) {
					System.out.println(">");
					return;
				}
				else if(s1.charAt(i)<s2.charAt(i)) {
					System.out.println("<");
					return;
				}
			}
			System.out.println("=");
			return;
		}
	}
}

```

### 4.8 矩形的数目

```txt
给你一个二维数组 `nums` ，其中 `nums[i]=[li,wi]` 表示第 `i` 个矩形的长度为 `li` 、宽度为 `wi` 。

如果存在 `k` 同时满足 `k≤li` 和 `k≤wi` ，就可以将第 `i` 个矩形切成边长为 `k` 的正方形。例如，矩形 `[5,7]` 可以切成边长最大为 `5` 的正方形。

设 `maxLen` 为可以从矩形数组 `nums` 切分得到的最大正方形的边长。

请你计算有多少个矩形能够切出边长为 `maxLen` 的正方形，并返回矩形数目 。

#### 输入输出格式

**输入格式** 一行二维整型数组。

**输出格式** 一行整数。

#### 输入输出样例

**输入** `[[2,3],[3,7],[4,3],[3,7]]` **输出** `3` **解释** `[[2,3],[3,7],[4,3],[3,7]]`中，`[3,7],[4,3],[3,7]`三个矩形都可以切出边长最大为 `3` 的正方形,因此输出 `3`。

#### 说明提示

- `1≤nums.length≤1000`
- `nums[i].length=2`
- `1≤li,wi≤109`
- `li\\=wi`
```

```java
package org.example;

import java.util.ArrayList;
import java.util.List;

public class Main1 {
    public static void main(String[] args) {
        String input = "[[2,3],[3,7],[4,3],[3,7]]"; // 替换为你的输入字符串

        // 解析输入的字符串为二维数组
        int[][] nums = parseInput(input);

        int result = countMaxLenSquares(nums);
        System.out.println("能切出最大正方形边长的矩形数量为：" + result);
    }

    public static int[][] parseInput(String input) {
        // 去除字符串中的非数字字符和方括号
        input = input.replaceAll("[^0-9,]", "");
        String[] parts = input.split(",");

        int[][] nums = new int[parts.length / 2][2];

        for (int i = 0; i < parts.length; i += 2) {
            nums[i / 2][0] = Integer.parseInt(parts[i]);
            nums[i / 2][1] = Integer.parseInt(parts[i + 1]);
        }

        return nums;
    }

    public static int countMaxLenSquares(int[][] rectangles) {
        int maxLen = 0;
        for (int[] rect : rectangles) {
            maxLen = Math.max(maxLen, Math.min(rect[0], rect[1]));
        }

        int count = 0;    
        for (int[] rect : rectangles) {
            if (Math.min(rect[0], rect[1]) >= maxLen) {
                count++;
            }
        }

        return count;
    }
}

```

### 4.9 坐标轴移动

```txt
给定一个初始坐标[0,0],初始方向向东，当输入.时移动一个单位，当输入<时逆时针旋转90度，当输入>时顺时针旋转90度

输入：给出字符串，例如..><><
输出：坐标
```

```java
import java.util.*;
public class Main {
    public static void main(String[] args) {
        //=======begin=======
        Scanner sc =new Scanner(System.in);
        String s = sc.next();
        int temp=0;
        int [] result  ={0,0};
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)=='.'){
               result= ld(result,temp);
            }else if(s.charAt(i)=='>'){
                temp=(temp-90)%360;
            }else if(s.charAt(i)=='<'){
                temp=(temp+90)%360;
            }
        }
        System.out.println(Arrays.toString(result));

        
    }
    public static int []ld(int s[],int temp){
        if(temp==90||temp==-270){
            s[1]=s[1]+1;
        }else if(temp==180||temp==-180){
            s[0]=s[0]-1;
        }else if(temp==270||temp==-90){
            s[1]=s[1]-1;
        }else if(temp==0){
            s[0]=s[0]+1;
        }
        return s;
    }
    //========end========
}
```

### 5.0 注册账号密码限制

```txt
为了更好地保护用户账户安全，很多网站对用户注册账号时输入的密码作出如下限制：

1.密码长度至少为8位；

2.大写字母、小写字母、数字、特殊符号（@、#、！、%、*、$、～等），以上四种至少包含两种。

请编写一个方法用于判断用户注册时输入的密码是否符合条件及强弱程度，具体判断依据如下：密码长度小于8则判定为不符合要求并输出“NG”；密码长度大于等于8时，若只包含一种符号，则判定为不符合要求并输出“NG”，若包含2种符号，则判定为中等强度并输出“MG”，若包含3种符号，则判定为强并输出“VG”，若包含全部4种字符为极强并输出“EG”。

输入说明：一个用户输入的密码字符串，可能存在大写字母、小写字母、数字、特殊符号，长度为n(0<=n<=1000)

输出说明：判断结果，若不符合条件，则输出“NG”；符合要求且强度中等，则输出MG，强则输出VG，极强则输出EG。

输入样例1: 12345678910

输入样例2: wer123Q
```

```java
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String str = scanner.next();
        int len = str.length();
        if (len < 8) {
            System.out.println("NG");
        } else {
            HashSet<Integer> record = new HashSet<>();//HashSet不重复
            for (int i = 0; i < len; i++) {
                char c = str.charAt(i);
                if (c >= 'A' && c <= 'Z') {
                    record.add(1);
                } else if (c >= 'a' && c <= 'z') {
                    record.add(2);
                } else if (c >= '0' && c <= '9') {
                    record.add(3);
                } else {
                    record.add(4);
                }
                if (record.size() == 1) {
                    System.out.println("NG");
                } else if (record.size() == 2) {
                    System.out.println("MG");
                } else if (record.size() == 3) {
                    System.out.println("VG");
                } else {
                    System.out.println("EG");
                }
            }
        }
    }
}

```

### 5.1 判断回文数1

```txt
输入一个正整数 n，判断其是否为回文数，若是回文数则输出 true，否则输出 false。
测试输入：

12345
预期输出：

false
测试输入：

12321
预期输出：

true
```

```java
import java.util.Scanner;

public class Palindrome {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String num = scanner.nextLine();
       
        Boolean flag = true;
        for (int i = 0, j = num.length() - 1; i < j; i++, j--) {
            if (num.charAt(i) != num.charAt(j)) {
                flag=false;
            } 
        }
        if(flag){
             System.out.println(flag);
        }else{
            System.out.println(flag);
        } 
    }
}
```

### 5.2 判断回文数2

```txt
小虎突然发现有些正整数的形状像一座“山”，比如123565321、145541，
它们左右对称（回文）且数位上的数字先单调不减，后单调不增。 
小虎 数了很久也没有数完，他想让你告诉他在区间[2023,20232023] 中有多少个数的形状像一座“山”。
提示
只需输出答案即可
```

```java
public class Main {
    public static void main(String[] args) {
        int ans = 0;
        for (int i = 2023; i < 20232024; i++) {
            if(judge(i+""))ans++;
        }
        System.out.println(ans);
    }
    public static boolean judge(String s){
        int n = s.length();
        //判断是否回文
        for (int i = 0; i < n/2; i++) {
            if(s.charAt(i)!=s.charAt(n-i-1))return false;
        }
        //判断数位的数字是否符合要求
        for (int i = 0; i < n/2; i++) {
            if(s.charAt(i)>s.charAt(i+1))return false;
        }
        return true;
    }
}
```

### 5.3 卡牌游戏

```txt
题目描述
阿岳在玩卡片拼接游戏，游戏规则如下:
每次会给你n张卡片，每张卡片上都会有一个字符，你需要将所有不重复的卡片按照ASCLL进行从大到小的排序，
得到的是无重复有序的字符串
输入
一个字符串s  表示所有的卡片

输出
一个有序且不重复的字符串

测试点数据规模与约定
对于100%的测试点，保证s 中所有的字符都是小写字母，且0≤s.length() ≤105

样例输入
aabcc
样例输出
cba
```

```java
//方法一 哈希表
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        char[] c = sc.nextLine().toCharArray();
        //arr数组记录每个字母是否出现
        boolean[] arr = new boolean[26];
        for(char temp : c){
            arr[temp - 'a'] = true;// arr[temp - 97] = true;
        }
        //从后往前输出字符串出现的字母
        for (int i = 25; i >= 0; i--) {
            if(arr[i]){
                System.out.print((char)(97+i));
            }
        }
    }
}
//方法二 HashSet(基于哈希表实现)
import java.util.*;

public class CardSorting {
    public static String sortUniqueChars(String s) {
        HashSet<Character> set = new HashSet<>();//
        
        // 将字符添加到 HashSet 去除重复
        for (char c : s.toCharArray()) {
            set.add(c);
        }
        
        // 转换成有序的字符数组
        Character[] uniqueChars = set.toArray(new Character[0]);//new Character[0] 是为了告诉 Java 应该创建一个 Character 类型的数组，以便将 HashSet 中的元素复制到这个数组中。
        Arrays.sort(uniqueChars, Collections.reverseOrder());
        
        // 构建最终的字符串
        StringBuilder result = new StringBuilder();
        for (char c : uniqueChars) {
            result.append(c);
        }
        
        return result.toString();
    }

    public static void main(String[] args) {
       Scanner sc =new Scanner(System.in);
        String s = sc.nextLine();
        String sortedUniqueChars = sortUniqueChars(s);

        System.out.println(sortedUniqueChars);
    }
}
// 方法三 TreeSet(基于红黑树)
import java.util.*;

public class CardSorting {
    public static String sortUniqueChars(String s) {
        TreeSet<Character> set = new TreeSet<>(Collections.reverseOrder());//TreeSet 是一个基于红黑树的实现，它可以对元素进行排序，并且不允许重复元素存在,通过传递 Collections.reverseOrder() 给 TreeSet 的构造函数，会创建一个按照自然顺序的逆序排序的 TreeSet 对象，即元素将按照 ASCII 码值从大到小的顺序排序。
        for (char c : s.toCharArray()) {
            set.add(c);
        }

        StringBuilder result = new StringBuilder();
        for (char c : set) {
            result.append(c);
        }

        return result.toString();
    }

    public static void main(String[] args) {
         String s = sc.nextLine();
        String sortedUniqueChars = sortUniqueChars(s);
        System.out.println(sortedUniqueChars);
    }
}
//方法四 HashSet去重，对ArraysList排序
import java.util.*;

public class CardSorting {
    public static String sortUniqueChars(String s) {
        HashSet<Character> set = new HashSet<>();

        // 将字符添加到 HashSet 去除重复
        for (char c : s.toCharArray()) {
            set.add(c);
        }

        // 将 HashSet 转换成 ArrayList
        ArrayList<Character> list = new ArrayList<>(set);

        // 对 ArrayList 中的元素进行排序
        Collections.sort(list, Collections.reverseOrder());//Arrays.sort() 方法用于对数组进行排序，而不是用于对集合（如 ArrayList）进行排序。因此，不能直接使用 Arrays.sort() 来对 ArrayList 进行排序。

        // 构建最终的字符串
        StringBuilder result = new StringBuilder();
        for (char c : list) {
            result.append(c);
        }

        return result.toString();
    }

    public static void main(String[] args) {
         String s = sc.nextLine();
        String sortedUniqueChars = sortUniqueChars(s);
        System.out.println(sortedUniqueChars);
    }
}

```



## 5.双指针法

### 双指针法理论基础

双指针法（快慢指针法）： **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

定义快慢指针

- 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
- 慢指针：指向更新 新数组下标的位置

删除过程如下：

![27.移除元素-双指针法](https://code-thinking.cdn.bcebos.com/gifs/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif)

### 代码随想录题目

[代码随想录 (programmercarl.com)](https://programmercarl.com/0027.移除元素.html)

### 自己遇到的题目



## 6.栈与队列

### 栈与队列理论基础



### 代码随想录题目



### 自己遇到的题目



## 7.二叉树

### 二叉树理论基础



### 代码随想录题目



### 自己遇到的题目



## 8.回溯算法

### 回溯理论基础  

**题目分类**

![回溯算法大纲](https://code-thinking-1253855093.file.myqcloud.com/pics/20210219192050666.png)



**什么是回溯法**

回溯法也可以叫做回溯搜索法，它是一种搜索的方式。

在二叉树系列中，我们已经不止一次，提到了回溯，例如[二叉树：以为使用了递归，其实还隐藏着回溯 (opens new window)](https://programmercarl.com/二叉树中递归带着回溯.html)。

回溯是递归的副产品，只要有递归就会有回溯。

**所以以下讲解中，回溯函数也就是递归函数，指的都是一个函数**。

**回溯法的效率**

回溯法的性能如何呢，这里要和大家说清楚了，**虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法**。

**因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案**，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。

那么既然回溯法并不高效为什么还要用它呢？

因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。

此时大家应该好奇了，都什么问题，这么牛逼，只能暴力搜索。

**回溯法解决的问题**

回溯法，一般可以解决如下几种问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

**相信大家看着这些之后会发现，每个问题，都不简单！**

另外，会有一些同学可能分不清什么是组合，什么是排列？

**组合是不强调元素顺序的，排列是强调元素顺序**。

例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。

记住组合无序，排列有序，就可以了。

**如何理解回溯法**

**回溯法解决的问题都可以抽象为树形结构**，是的，我指的是所有回溯法的问题都可以抽象为树形结构！

因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。

递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。

这块可能初学者还不太理解，后面的回溯算法解决的所有题目中，我都会强调这一点并画图举相应的例子，现在有一个印象就行。

**回溯法模板**

这里给出Carl总结的回溯算法模板。

在讲[二叉树的递归 (opens new window)](https://programmercarl.com/二叉树的递归遍历.html)中我们说了递归三部曲，这里我再给大家列出回溯三部曲。

- 回溯函数模板返回值以及参数

在回溯算法中，我的习惯是函数起名字为backtracking，这个起名大家随意。

回溯算法中函数返回值一般为void。

再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。

但后面的回溯题目的讲解中，为了方便大家理解，我在一开始就帮大家把参数确定下来。

回溯函数伪代码如下：

```text
void backtracking(参数)
```

1

- 回溯函数终止条件

既然是树形结构，那么我们在讲解[二叉树的递归 (opens new window)](https://programmercarl.com/二叉树的递归遍历.html)的时候，就知道遍历树形结构一定要有终止条件。

所以回溯也有要终止条件。

什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。

所以回溯函数终止条件伪代码如下：

```text
if (终止条件) {
    存放结果;
    return;
}
```

1
2
3
4

- 回溯搜索的遍历过程

在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。

如图：

![回溯算法理论基础](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png)

注意图中，我特意举例集合大小和孩子的数量是相等的！

回溯函数遍历过程伪代码如下：

```text
for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
}
```

1
2
3
4
5

for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。

backtracking这里自己调用自己，实现递归。

大家可以从图中看出**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。

分析完过程，回溯算法模板框架如下：

```text
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

1
2
3
4
5
6
7
8
9
10
11
12
13

**这份模板很重要，后面做回溯法的题目都靠它了！**

如果从来没有学过回溯算法的录友们，看到这里会有点懵，后面开始讲解具体题目的时候就会好一些了，已经做过回溯法题目的录友，看到这里应该会感同身受了。

### 代码随想录题目

https://www.programmercarl.com/0077.%E7%BB%84%E5%90%88.html

### 自己遇到的题目



## 9.贪心算法

### 贪心理论基础

题目分类大纲如下：

![贪心算法大纲](https://code-thinking-1253855093.file.myqcloud.com/pics/20210917104315.png)

**什么是贪心**

**贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。

这么说有点抽象，来举一个例子：

例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？

指定每次拿最大的，最终结果就是拿走最大数额的钱。

每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。

再举一个例子如果是 有一堆盒子，你有一个背包体积为n，如何把背包尽可能装满，如果还每次选最大的盒子，就不行了。这时候就需要动态规划。动态规划的问题在下一个系列会详细讲解。

**贪心的套路（什么时候用贪心）**

很多同学做贪心的题目的时候，想不出来是贪心，想知道有没有什么套路可以一看就看出来是贪心。

**说实话贪心算法并没有固定的套路**。

所以唯一的难点就是如何通过局部最优，推出整体最优。

那么如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？

**不好意思，也没有！** 靠自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。

有同学问了如何验证可不可以用贪心算法呢？

**最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧**。

可有有同学认为手动模拟，举例子得出的结论不靠谱，想要严格的数学证明。

一般数学证明有如下两种方法：

- 数学归纳法
- 反证法

看教课书上讲解贪心可以是一堆公式，估计大家连看都不想看，所以数学证明就不在我要讲解的范围内了，大家感兴趣可以自行查找资料。

**面试中基本不会让面试者现场证明贪心的合理性，代码写出来跑过测试用例即可，或者自己能自圆其说理由就行了**。

举一个不太恰当的例子：我要用一下1+1 = 2，但我要先证明1+1 为什么等于2。严谨是严谨了，但没必要。

虽然这个例子很极端，但可以表达这么个意思：**刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心**。

**例如刚刚举的拿钞票的例子，就是模拟一下每次拿做大的，最后就能拿到最多的钱，这还要数学证明的话，其实就不在算法面试的范围内了，可以看看专业的数学书籍！**

所以这也是为什么很多同学通过（accept）了贪心的题目，但都不知道自己用了贪心算法，**因为贪心有时候就是常识性的推导，所以会认为本应该就这么做！**

**那么刷题的时候什么时候真的需要数学推导呢？**

例如这道题目：[链表：环找到了，那入口呢？ (opens new window)](https://programmercarl.com/0142.环形链表II.html)，这道题不用数学推导一下，就找不出环的起始位置，想试一下就不知道怎么试，这种题目确实需要数学简单推导一下。

**贪心一般解题步骤**

贪心算法一般分为如下四步：

- 将问题分解为若干个子问题
- 找出适合的贪心策略
- 求解每一个子问题的最优解
- 将局部最优解堆叠成全局最优解

这个四步其实过于理论化了，我们平时在做贪心类的题目 很难去按照这四步去思考，真是有点“鸡肋”。

做题的时候，只要想清楚 局部最优 是什么，如果推导出全局最优，其实就够了。

**总结**

本篇给出了什么是贪心以及大家关心的贪心算法固定套路。

**不好意思了，贪心没有套路，说白了就是常识性推导加上举反例**。

最后给出贪心的一般解题步骤，大家可以发现这个解题步骤也是比较抽象的，不像是二叉树，回溯算法，给出了那么具体的解题套路和模板。

### 代码随想录题目

https://www.programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html

### 自己遇到的题目



### 9.1花花快长大

```txt
阿岳的女朋友很喜欢花！
为次阿岳亲自种了一个花园，每天都会去浇水，每朵花都有一个长度，浇水后长度会增高1。
其中花园里有n朵花，阿岳会每天挑选n-1朵花浇水，最少多少天所有的花会一样长?

输入
第一行 一个整数n  表示花的个数
第二行 n 个整数ai   表示每朵花的初始长度 (0≤i ＜n )
输出
一个整数  表示使所有元素相等的最小操作次数
测试点数据规模与约定
对于100%的测试点，保证0<n <104，0≤ai <104

样例输入
3
1 2 3
样例输出
3
提示
样例数据中，每次操作增加2个元素的值 ，最少操作3次
[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
数学思维能力是学习数学的核心能力,逆向思维是数学思维中一个重要表现形式,在数学基础知识和解题方法中发挥着不可替代的作用.
```

```java
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        int ans = 0;
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }

        Arrays.sort(arr); // 对数组进行排序

        int min = arr[0]; // 直接取排序后的数组的第一个元素即为最小值

        // 每浇一次，就能使最小值与没被浇的差-1
        //[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
     
        for (int num : arr) {
            ans += num - min;
        }

        System.out.println(ans);
    }
}
   //这个问题可以通过数学的思维进行解决，特别是在寻找最优解的情况下。一个关键点是，阿岳每天都浇水，只选择 n-1 朵花进行浇水。这意味着每次选择的 n-1 朵花中，必定有一朵花每天都不会浇水。考虑到这一点，我们可以找出这 n 朵花中最小的长度作为基准值，然后通过浇水来增加其他花朵的长度，使它们和基准值相等。最小操作次数即为所有花长度与基准值的差值之和。

```



### 9.2 除草

```txt
题目描述
阿岳一共种了n块地，为了让地的产量更高，阿岳每天都会去地里除草(除草后仍会长草)，
由于一些原因阿岳一天只能除一块地的草，n 天后阿岳将所有地都除了一遍草，但每块地草
的生长速度vi 不同，n 天后所有草的长度总和的最小值是多少呢？
测试点数据规模
对于100%的测试点，保证 0<n <1000 1<vi <1000

输入
第一行输入一个整数n(表示地的块数)
第二行n个数(表示杂草的生长速度)
输出
n天后所有草的长度总和
样例输入
3
1 3 2
样例输出
4
提示
第一天：除第一块地的草，总长度0+3+2=5
第二天：除第三块地的草，总长度1+6+0=7
第三天：除第二块地的草，总长度2+0+2=4
```

```java
import java.util.Arrays;
import java.util.Scanner;
//岳神除草
public class Main {
public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    int arr[]=new int [n];
    for(int i=0;i<n;i++) {
        arr[i]=sc.nextInt();
    }
    Arrays.sort(arr);//根据规律，长得越快，放到最后除
    int sum=0;
    for(int i=0;i<n;i++) {
        sum+=Arrays.stream(arr).sum()-arr[i]*(i+1);
    }
    //Arrays.stream(arr)求数组总和
    System.out.println(sum);
}
}
```



### 9.3排队买票

小伊同学在暑假的时候来到电影院打工。正巧赶上电影院，一部新的电影要上映。题目中会给你一个整数数组 `num` 代表排队买票的人付的钱。来排队买票的人都只会拿出一张 `25`，`50` 或 `100` 元的钞票购买电影票。电影票的价格是 `25` 元，小伊同学刚开始手里没有初始金钱，现在请你帮小伊同学编写代码，判断一下她是否可以正常的给这 `n` 个人售票并找零？
输入格式一个整数数组。
输出格式 `True`或`False`。
输入输出样例1输入25输出True
输入输出样例2输入50 25输出False

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] bills = new int[n];

        for (int i = 0; i < n; i++) {
            bills[i] = scanner.nextInt();
        }

        boolean result = canSellTickets(n, bills);
        System.out.println(result ? "True" : "False");
    }

    public static boolean canSellTickets(int n, int[] bills) {
        int k = 0;
        int j = 0;

        for (int i = 0; i < n; i++) {
            int l = bills[i];

            if (l == 25) {
                k += 1;//如果是25手中持有的25加一
            } else if (l == 50) {
                k -= 1;//如果是50块钱，需要找回25，所以手中的钱减一
            } else if (l == 100) {
                k -= 3;//同理，可得100是减三
            }

            if (k < 0) {
                return false;//如果k小于零证明手中已经没有钱了，直接退出循环
            }

            j++;
        }

        return j >= n;
    }
}

```

### 9.4 数组跳跃

```txt
题目描述
小岳岳在抖音发布了一条视频，视频中他问道：“我这一生如履薄冰，你说我能走到对岸吗？”
现输入一个非负整数数组 nums ，小岳岳最初位于数组的第一个下标，数组中的每个元素代表小岳岳在该位置可以向前跳跃的最大长度。请你判断小岳岳是否能够走到对岸（到达最后一个下标），如果可以，输出 true ；否则，输出 false 。
输入
一个字符串 形式为一串以","隔开的整数ai  表示数组nums
输出
一个布尔值(true或false)  表示能否到达最后一个下标

测试点数据规模与约定
对于100%的测试点，保证0<nums.length <10，0≤ai <5


样例输入
2,3,1,1,4
样例输出
true
提示
nums = [2,3,1,1,4] 结果为true  解释： 可以先跳 1 步，从下标 0 到达下标 1,
然后再从下标 1 跳 3 步到达最后一个下标。
```

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println(judge(sc.nextLine().split(",")));
    }
    public static boolean judge(String[] s){
        int len = 0;//记录能够跳到的最远位置。
        int n = s.length-1;
        for (int i = 0; i < n&&i<=len; i++) {//
            len = Math.max(len,i+Integer.parseInt(s[i]));//将其设置为当前位置能够到达的最远位置
            // [2,3,1,1,4] 
            // [0,1,2,3,4]下标
            //len= max(0,0+2); 
            //len= max(2,1+3);
            //len= max(4,2+1);
            //len= max(4,3+1);
            //len= max(4,4+4);
            if(len >= n)break;  // 8>5 如果 len 已经可以到达最后一个位置，就提前结束循环，因为已经满足条件了。
        }
        return len >= n;   // 8 > 5
     
    }
}
//i < n: 这个条件确保循环索引 i 不会超出数组的长度。因为数组的索引是从 0 开始的，所以当 i 达到 n（数组长度）时，就超出了数组的范围，遍历也就不再需要了。
//i <= len: 这个条件是基于贪心算法的思想。它确保只在当前已知能够到达的范围内进行遍历。len 记录了当前能够到达的最远位置，因此只有当当前的索引 i 在这个范围内时，才继续进行遍历。如果 i 超出了当前能够到达的范围 len，就没有必要再继续遍历了，因为已经无法到达后面的位置了
```



## 10.动态规划

### 动态规划理论基础

动态规划刷题大纲

![img](https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%80%BB%E7%BB%93%E5%A4%A7%E7%BA%B21.jpg)

**什么是动态规划**

动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。

所以动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的，

在[关于贪心算法，你该了解这些！ (opens new window)](https://programmercarl.com/贪心算法理论基础.html)中我举了一个背包问题的例子。

例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。

但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。

所以贪心解决不了动态规划的问题。

**其实大家也不用死扣动规和贪心的理论区别，后面做做题目自然就知道了**。

而且很多讲解动态规划的文章都会讲最优子结构啊和重叠子问题啊这些，这些东西都是教科书的上定义，晦涩难懂而且不实用。

大家知道动规是由前一个状态推导出来的，而贪心是局部直接选最优的，对于刷题来说就够用了。

上述提到的背包问题，后序会详细讲解。

**动态规划的解题步骤**

做动规题目的时候，很多同学会陷入一个误区，就是以为把状态转移公式背下来，照葫芦画瓢改改，就开始写代码，甚至把题目AC之后，都不太清楚dp[i]表示的是什么。

**这就是一种朦胧的状态，然后就把题给过了，遇到稍稍难一点的，可能直接就不会了，然后看题解，然后继续照葫芦画瓢陷入这种恶性循环中**。

状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。

**对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！**

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

一些同学可能想为什么要先确定递推公式，然后在考虑初始化呢？

**因为一些情况是递推公式决定了dp数组要如何初始化！**

后面的讲解中我都是围绕着这五点来进行讲解。

可能刷过动态规划题目的同学可能都知道递推公式的重要性，感觉确定了递推公式这道题目就解出来了。

其实 确定递推公式 仅仅是解题里的一步而已！

一些同学知道递推公式，但搞不清楚dp数组应该如何初始化，或者正确的遍历顺序，以至于记下来公式，但写的程序怎么改都通过不了。

后序的讲解的大家就会慢慢感受到这五步的重要性了。

**动态规划应该如何debug**

相信动规的题目，很大部分同学都是这样做的。

看一下题解，感觉看懂了，然后照葫芦画瓢，如果能正好画对了，万事大吉，一旦要是没通过，就怎么改都通过不了，对 dp数组的初始化，递推公式，遍历顺序，处于一种黑盒的理解状态。

写动规题目，代码出问题很正常！

**找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！**

一些同学对于dp的学习是黑盒的状态，就是不清楚dp数组的含义，不懂为什么这么初始化，递推公式背下来了，遍历顺序靠习惯就是这么写的，然后一鼓作气写出代码，如果代码能通过万事大吉，通过不了的话就凭感觉改一改。

这是一个很不好的习惯！

**做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。

然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。

如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。

如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

**这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了**。

这也是我为什么在动规五步曲里强调推导dp数组的重要性。

举个例子哈：在「代码随想录」刷题小分队微信群里，一些录友可能代码通过不了，会把代码抛到讨论群里问：我这里代码都已经和题解一模一样了，为什么通过不了呢？

发出这样的问题之前，其实可以自己先思考这三个问题：

- 这道题目我举例推导状态转移公式了么？
- 我打印dp数组的日志了么？
- 打印出来了dp数组和我想的一样么？

**如果这灵魂三问自己都做到了，基本上这道题目也就解决了**，或者更清晰的知道自己究竟是哪一点不明白，是状态转移不明白，还是实现代码不知道该怎么写，还是不理解遍历dp数组的顺序。

然后在问问题，目的性就很强了，群里的小伙伴也可以快速知道提问者的疑惑了。

**注意这里不是说不让大家问问题哈， 而是说问问题之前要有自己的思考，问题要问到点子上！**

**大家工作之后就会发现，特别是大厂，问问题是一个专业活，是的，问问题也要体现出专业！**

如果问同事很不专业的问题，同事们会懒的回答，领导也会认为你缺乏思考能力，这对职场发展是很不利的。

所以大家在刷题的时候，就锻炼自己养成专业提问的好习惯。

**总结**

这一篇是动态规划的整体概述，讲解了什么是动态规划，动态规划的解题步骤，以及如何debug。

动态规划是一个很大的领域，今天这一篇讲解的内容是整个动态规划系列中都会使用到的一些理论基础。

在后序讲解中针对某一具体问题，还会讲解其对应的理论基础，例如背包问题中的01背包，leetcode上的题目都是01背包的应用，而没有纯01背包的问题，那么就需要在把对应的理论知识讲解一下。

大家会发现，我讲解的理论基础并不是教科书上各种动态规划的定义，错综复杂的公式。

这里理论基础篇已经是非常偏实用的了，每个知识点都是在解题实战中非常有用的内容，大家要重视起来哈。

今天我们开始新的征程了，你准备好了么？

### 代码随想录题目

https://www.programmercarl.com/0509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.html

### 自己遇到的题目

### 10.2 买口罩（0-1背包）

```txt
某药店为了回馈顾客，拿出7个品牌的口罩做特价限购活动：A品牌是3个装2元，B品牌是3个装3元，C品牌是4个装2元，D品牌是5个装3元，E品牌是4个装5元，F品牌是1个装2元，G品牌是2个装2元，每个品牌只能买一包。小涵拿N元钱去药店买特价口罩，小涵最多能买多少个口罩？
注意：通过手算直接输出结果视作无效作答。输入说明：钱数N元（0＜＝N＜＝100）。

输出说明：能买到的口罩最大数量。输入样例1：10

输入样例2：25 输出样例1：15 输出样例2：22
```

```java
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[][] nums = new int[][]{
                {2, 3},
                {3, 3},
                {2, 4},
                {3, 5},
                {5, 4},
                {2, 1},
                {2, 2},
        };
        int[] record = new int[n + 1];
        for (int i = 0; i < nums.length; i++) {//遍历口罩品牌
            for (int j = n; j >= nums[i][0]; j--) {//从当前钱数n开始向前遍历，更新record数组
                record[j] = Math.max(record[j], record[j - nums[i][0]] + nums[i][1]);//这行代码更新了record数组中不同价格下能购买的最大口罩数量。它利用状态转移方程来更新record数组，保留了在当前价格下能购买的最大口罩数量。
            }
        }
        System.out.println(record[n]);
    }
}


```



## 11.单调栈

### 单调栈理论基础



### 代码随想录题目



### 自己遇到的题目

## 12.图论

### 图论理论基础



### 代码随想录题目



### 自己遇到的题目



## 13.暴力破解



## 14.排序

[十大排序算法超全大综合，动图演示，你真的值得拥有！ - 力扣（LeetCode）](https://leetcode.cn/circle/discuss/rzsN73/)

## 15.数学和传统问题

### 15.1孔融让梨

```txt
孔融让梨一直是中国古代故事中谦逊的榜样。今天孔融又拿到了一些梨，他决定分给他的兄弟们，由于孔融很谦逊，他必须保证分给他兄弟的梨比自己的梨多。题目中会给你一行两个整数 `n` 和 `k` 代表，孔融要分给 `n` 个兄弟和他手里有 `k` 个梨。现在请你编写代码帮孔融计算，他最多能吃到多少个梨。

输入格式 一行两个整数 `n` 和 `k`。

输出格式 一个整数。

输入输出样例 输入 `5 10 输出 `0
```



```java
import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner scn=new Scanner(System.in);
        int n=scn.nextInt(),k=scn.nextInt();
        if(k%(n+1)>=n)//如果均分后的数量能够再给他每个兄弟分一个,则能得到k/(n+1)
        System.out.print(k/(n+1));
        else//否则为k/(n+1)-1个
        System.out.print(k/(n+1)-1);
    }
}
```

### 15.2擂台赛

```txt
小艾和他的两个朋友决定来一场羽毛球擂台赛。他们的编号分别是 `1,2,3`，一号和二号先单挑赢的人留在场上，输的人换另外一个在场下的人上场继续比。

现在题目中会给你一个整数数组 `num`，代表的是在擂台上同学的序号，现在请你编写代码判断 `num` 当中的序列是否合法。如果合法，则返回 `True`，否则返回 `False`。


输入格式 第一行，一行整数代表 `num`。

输出格式 `True` 或 `False`。

输入输出样例1输 入1 2 3输出 False

输入输出样例2输入 2 3 1输出 True
```



```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        boolean flag = true;
        int[] a = {1, 2};
        
        while (n-- > 0) {
            int x = scanner.nextInt();
            if (x == a[0]) {
                a[1] = 6 - a[0] - a[1];//2位置换另一个上
            } else if (x == a[1]) {
                a[0] = 6 - a[0] - a[1];//1位置换另一个上
            } else {
                flag = false;
            }
        }
        
        if (flag) {
            System.out.println("True");
        } else {
            System.out.println("False");
        }
    }
}

```

### 15.3数组的排列方式

```txt
小叶同学最近正在学习数组。在做题的时候，他发现了一道关于数组的题，却没有办法做出来，想让你帮他一下。

题目中首先会给你一个整数 `n`，代表 `1` 到 `n` 之间的数字，你可以无限使用 `1` 到 `n` 之间的数字。然后题目中会给你一个整数 `k`，需要你从这 `n` 个数字中取出 `k` 个数字，并按顺序排列起来，但是相邻的数字不能相同，小叶同学想知道这样有多少种排列方法，现在请你帮小叶编写代码，算出结果并输出。（结果对 `1000000007` 取模）

输入格式一行两个整数，`n` 和 `k`。

输出格式 一个整数。

输入输出样例1输入 2 2输出2

输入输出样例2输入1 5输出 `5`
```



```java
import java.util.Scanner;

public class Main {

    private static final long MOD = 1000000007; // 定义常量MOD为固定值1000000007

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in); // 使用Scanner类从键盘获取输入
        int n = sc.nextInt(); // 读取整数n
        int m = sc.nextInt(); // 读取整数m

        long[] dp = new long[m + 1];
        dp[1] = m;

        for (int i = 2; i <= m; i++) {
            dp[i] = dp[i-1] * (m - 1) % MOD; // 更新dp[i]
        }

        System.out.println(dp[m]); // 输出结果
    }
}

```

### 15.4小熊吃水果

```txt
小熊采摘回来了三种水果，他决定每天吃两个不同种类的水果各一个。在题目中会给你三个整数 `a,b,c`，分别代表三种水果的数量，现在请你编写代码，帮小熊算一下他最多能吃多少天？

输入格式 一行三个整数 `a,b,c`。

输出格式 一个整数。

输入输出样例1输入 `1 1 1输出`1

输入输出样例2输入 `5 6 8`输出 `9`
```



```java
package org.example;

import java.util.Arrays;
import java.util.Scanner;
import java.lang.Math;

public class BankRate {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int []arr = new int[3];
        for (int i = 0; i < 3; i++) {
            arr[i] = sc.nextInt();
        }
        Arrays.sort(arr);

      
        int days = 0;
        while (arr[1] > 0 && arr[2] > 0) {
            arr[1]--;
            arr[2]--;
            Arrays.sort(arr);//总是从吃的最多的两种水果吃
            days++;
        }
        System.out.println(days);
    }
}



```

### 15.5数位组合之八

```txt
本关任务：函数 `fun` 的功能是：将两个两位数的正整数 `a、b` 合并形成一个整数放在 `c` 中。合并的方式是：将 `a` 数的十位和个位数依次放在 `c` 数的十位和千位上，`b` 数的十位和个位数依次放在 `c`数的百位和个位上。输入格式

整数 `a、b`。

输出格式

计算得到的结果`c`。

输入输出样例

输入1
45 12
输出1
5142
```

```java
import java.util.Scanner;    
public class Main {
public static void main(String[] args) {
        int a,b;
        long c = 0l;
        Scanner input = new Scanner(System.in);
        a = input.nextInt();
        b = input.nextInt();
        c=fun(a,b,c);
        System.out.println(c);

    }

    public static long fun(int a,int b,long c) {
        int a1,a2,a3,a4;
        a1 = a%10;//获取数的个位
        a2 = a/10%10;//获取数的十位
        a3 = b%10;
        a4 = b/10%10;
        c =(long) (a1*1000+a4*100+a2*10+a3);
        return c;
    }
}   
```

### 15.6判断质数

```java
public boolean judgePrime(int num){
	boolean flag=true;
    if(num==1||(num)%2==0&&num!=2){
        flag=false;
    }else{
        for(int j=3;j<Math.sqrt(num);j+=2){
            if(num%j==0){
                flag=false;
                break;
            }
        }
    }
    return flag;
}
```

### 15.7进制转换

```txt
将一个十进制数*n* 转换为26进制
用abcd....z表示0123...25(每位数字都用小写英文字母表示)

对于100%的测试点，保证0<*n* <1000

输入一个十进制数*n*

输出一个字符串*s* 表示用字符表示的26进制数

样例输入
26
样例输出
ba

26转换为26进制为10
1、0分别对应b、a
如：28为bc
```



```java
方法一
public static String decimalTo26Base(int n) {
        StringBuilder sb = new StringBuilder();
        while (n > 0) {
            int remainder = (n - 1) % 26; // 计算余数  n,开头为a=0 n-1开头,开头为a=1
            sb.insert(0, (char) ('a' + remainder)); // 将余数对应的字符插入到字符串的开头
            n = (n - 1) / 26; // 更新n为商
        }
        return sb.toString();
    }
```

```java
方法二
String result = "";
        
        while (n > 0) {
            int remainder = (n - 1) % 26; // 计算余数
            result = (char) ('a' + remainder) + result; // 将余数对应的字符插入到结果字符串的开头
            n = (n - 1) / 26; // 更新n为商
        }
```

```java
方法三
Integer.toString(int i,int radix)   //i为要转化的数,radix为要转换的进制
```

### 15.6整数反转

```java
public static int getRreverse(int x){
	int res=0;
	while(x!=0){
		int temp=x%10;
		res=res*10+temp;
		x/=10
	}
	return res
}
//132
//temp=132%10=2    res=0=0+2    x=13
//temp=13%10=3     res=2*10+3   x=1
//temp=1%10=1      res=23*10+1  x=0
```

### 15.7取七去四

```txt
要求输出1∼n内含有7或者7的倍数的数字，但不含有4或者4的倍数的个数，例如（17，27，70，71…）。阿岳一看到这个题目，就觉得很兴奋，他觉得这是老师给他的一个挑战，也是一个展示自己才华的机会。

**输入**

一个整数 *n*

**输出**

一个整数 表示不大于*n* 的与7有关的数字但与4无关的个数。

**测试点数据规模与约定**

对于 100% 的数据，保证1≤*n*≤30000 。

样例输入
40
样例输出
6
提示
如 40 以内与 7 有关但与 4 无关的数为 7，17，21，27，35，37 共 6 个。
```



```java
import java.util.*;
public class q1539 {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt();
		
		int cnt=0;
		for(int i=1;i<=n;i++) if(check(i)) cnt++;
		
		System.out.println(cnt);
	}
	
	public static boolean check(int i) {
		int t=i;
		
		boolean flag7=false;
		while(i!=0) {
			if(i%10==4) return false;
			if(i%10==7) flag7=true;
			i=i/10;
		}
		
		return (t%7==0||flag7)&&t%4!=0;
		
	}
}

```

### 15.8求距离

```txt
要求给出一个1−>n 的排列，然后有一次机会可以交换两个数的位置，求交换后最小值和最大值之间的最大距离是多少

**输入**

第一行 一个整数*n* 表示排列的元素个数
第二行 *n* 个整数 表示这个排列的顺序

**输出**

一个整数  表示最小值与最大值之间的最大距离

**测试点数据规模与约定**

对于100%的测试点，保证 1<*n* ≤100

样例输入
5
4 5 1 3 2
 
样例输出
3
```

```java
找到最大和最小的位置比较距离两端的差值
import java.util.*;
public class q1541 {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt();
		int[] arr=new int[n];
		
		for(int i=0;i<n;i++) arr[i]=sc.nextInt();
		
		int max=0,p=-1,min=110,q=-1;
		for(int i=0;i<n;i++) {
			if(max<arr[i]) {
				max=arr[i];
				p=i;
			}
			if(min>arr[i]) {
				min=arr[i];
				q=i;
			}
		}
		
		int l=Math.min(p,q);
		int r=Math.max(p,q);
		
		System.out.println(Math.max(r, n-l-1));
	}
	
	
}

```

### 16.9二进制与位运算

```txt
给你一个整数 *n* ，对于 0 <= *i* <= *n* 中的每个 *i* ，计算其二进制表示中 1 的个数 ，并按字符串形式输出一个长度为 *n + 1* 的数组作为答案。

**输入**

一个整数*n*

**输出**

一个字符串 表示答案数组

**测试点数据规模与约定**

对于100%的测试点，保证0<*n* <105

样例输入
2
样例输出
[0, 1, 1]
```



```java
//位运算x>>1等价于x=x/2 
import java.util.*;
public class q1542 {
	public static void main(String[] args) {
		Scanner sc =new Scanner(System.in);
		int n=sc.nextInt();
		int[] ans=new int[n+1];
		
		for(int i=0;i<=n;i++) ans[i]=bits(i);
		
		System.out.println(Arrays.toString(ans));
	}
	public static int bits(int x) {
		int cnt=0;
		while(x!=0) {
			if((x&1)==1)cnt++;
			x/=2;
		}
		return cnt;
	}
}

```

### 16.10第一重要极限

```txt
小岳是工科大一新生，正在学习高等数学里的"第一重要极限”，小岳突然心血来潮，想通过计算机程序求出形如:lim(x±∞) sin6x /2x的极限值
请你帮帮小岳，设计一个程序求出此极限
结果保留两位小数
输入
第一行 一个整数n 表示公式的数量
接下来n行 每行有两个字符串sinax bx 用单个空格分隔
输出
输出共有n行
每行包含一个保留两位的小数


测试点数据规模与约定
对于50%的测试点，保证a 、b 均为整数且a ,b >0
对于100%的测试点，保证公式有解且非±∞


样例输入
2
sin6x 2x
sin4x 2x
样例输出
3.00
2.00
```



```java
import java.util.*;
public class q1544 {
	
	public static int value(String s) {
		int ans=0;
		int p=0;
		
		if(s.charAt(0)=='s') p=3;
		while(p<s.length()&&s.charAt(p)<='9'&&s.charAt(p)>='0') {
			ans=ans*10+(int)(s.charAt(p)-'0');
			p++;
		}
		
		if(ans==0) return 1;
		return ans;
	}
	
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		String s1,s2;
		int n;
		n=sc.nextInt();
		
		while(n--!=0){
		   s1=sc.next();
		   s2=sc.next();
		   System.out.printf("%.2f\n",1.0*value(s1)/value(s2));
		}
		
	}
}


```

### 16.11 判断是否为素数

```java
public boolean judgePrime(int num){
	boolean flag=true;
    if(num==1||(num)%2==0&&num!=2){
        flag=false;
    }else{
        for(int j=3;j<Math.sqrt(num);j+=2){
            if(num%j==0){
                flag=false;
                break;
            }
        }
    }
    return flag;
}
```

```

```



### 16.12  a与b之间的素数

```txt
输入 2 个正整数 a 和 b，输出 a 与 b 范围内的所有素数。

测试输入：
1
25
预期输出：
1 2 3 5 7 11 13 17 19 23 
```

```java
package org.example;

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        for (int i = a; i <= b; i++) {
        boolean c = true;
            for (int j = 2; j <= i / 2; j++) {
                if (i % j == 0 || i == j) {
                    c = false;
                    break;
                }
            }
            if (c) {
                System.out.print(i + " ");
            }
        }
    }
}
```

### 16.13 出去玩喽

```txt
题目描述
周末了，阿岳出去玩，从学校到曹魏古城还是坐校门口的公交车划算。
共有n 站路，阿岳刚上车时车上有m 个人，每到一站都有x 个人上车，y 个人下车，问这一路上公车上最多有多少人。

输入
第一行 两个整数n ，m  分别表示站点个数(不包括起点站)和初始人数
接下来n 行 每行有两个整数x，y   分别表示第i 个站点上车的人数与下车的人数(0<i ≤n )

输出
一个整数  表示公交车上最多的人数

测试点数据规模与约定
对于100%的测试点，保证0<n ≤20，0≤m ,x ,y ≤10
样例输入
2 3
5 2
3 5
样例输出
6
提示
阿岳和司机不是人
```

```java
//方法1
import java.util.Scanner;

public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int num = sc.nextInt();
        int max = 0;
        for (int i = 0; i < n; i++) {
            max = Math.max(max,num);//先更新max,防止出错
            num += sc.nextInt();
            num -= sc.nextInt();
        }
        System.out.println(max);
    }
}

//方法1 改进
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 站点个数
        int m = sc.nextInt(); // 初始人数
        int maxPassengers = m; // 最多乘客数

        for (int i = 0; i < n; i++) {
            int x = sc.nextInt(); // 上车人数
            int y = sc.nextInt(); // 下车人数

            m = m - y + x; // 更新当前乘客数
            maxPassengers = Math.max(maxPassengers, m); // 更新最多乘客数
        }
        System.out.println(maxPassengers);
    }
}

//方法2
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[][] arr = new int[n][2];
        int max = m;
        for (int i = 0; i < n; i++) {
            arr[i][0] = sc.nextInt();
            arr[i][1] = sc.nextInt();
        }
        for (int i = 0; i < n; i++) {
            m = m + arr[i][0] - arr[i][1];
            max = Math.max(max, m);
        }
        System.out.println(max);
    }
}

```

### 16.4  前n项和与积

```
数学是任何工科的基础，因此，扎实的数学功底至关重要。很多算法都体现着数学思维，请你们仔细感悟。
现在给你n个数据a1，a2，a3，a4，a5，an，请你求出他们的前n项和与前n项积

共一行包含n个数据0<=n<=10,用空格分开每个数据aj，0<=ai<=100

第一行输出s1,s2,s3,sn的值，第二行输出前n项积

输入数据 
1 2 7
输出数据 
1 3 10
1 2 14
```

```java
package org.example;

import java.util.Scanner;

import java.util.Scanner;

public class Main{
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读取n个数
        String[] inputs = scanner.nextLine().split(" ");
        int n = inputs.length;

        // 将字符串数组转换为整数数组
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = Integer.parseInt(inputs[i]);
        }

        // 计算前n项和
        int sum = 0;
        for (int i = 0; i < n; i++) {
            sum += nums[i];
            System.out.print(sum + " ");
        }
        System.out.println();

        // 计算前n项积
        int product = 1;
        for (int i = 0; i < n; i++) {
            product *= nums[i];
            System.out.print(product + " ");
        }
    }
}
```

```java
import java.util.Scanner;
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ArrayList<Integer> list = new ArrayList<>();
        int sum = 0;
        int mul = 1;

        while (scanner.hasNextInt()) {
            int temp = scanner.nextInt();
            if (temp == -1) {
                break; // 如果输入-1，则结束输入
            }
            list.add(temp);
        }
        for (int a : list) {
            sum += a;
            System.out.print(sum + " ");
        }
        System.out.println();
        for (int b : list) {
            mul *= b;
            System.out.print(mul + " ");
        }
    }
}
// IntelliJ IDEA的控制台不支持直接输入结束标记以表示输入的结束
```



## 16高阶算法

### KMP算法



## 17递归算法



### 递归理论基础



